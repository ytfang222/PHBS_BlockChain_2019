## homework1

姓名：方雨婷  学号1901212576

这个作业处理的是Scrooge Coin系统的交易，目标是验证交易内容的合法性和对交易处理生成账本记录。作为程序的数据，会有一批交易生成，生成之后需要将UTXO放入UTXOPool处理。

#####1、public TxHandler(UTXOPool utxoPool); 

```java
public UTXOPool utxoPool;
    public TxHandler(UTXOPool utxoPool) {
        // IMPLEMENT THIS
        this.utxoPool = new UTXOPool(utxoPool);
    }
```

UTXO是未被处理的output，UTXOPool是未被处理的output的交易池。

UTXO包含交易的ID txHash和交易output的index。给出一个UTXO就能唯一确认一个output，通过txHash找到交易，通过index找到output。

UTXOPool把前面的UTXO和output进行组合放到一个池中，UTXO是索引，Transaction.Output是具体内容，每次有未被处理的交易产生，就需要将所有的output放入池中等待处理。



##### 2、public boolean isValidTx(Transaction tx); 

检验Transaction tx的合法性。

创建规则，检验交易的合法性。满足5条check则返回为true。

a.所有输出都由UTXOPool提供

b.输出的签名有效

c.没有重复使用UTXOPool的内容

d.输出值非负

e.输出值大于输入值

```Java
public boolean isValidTx(Transaction tx) {
        // For Rule5
        double outputSum = 0;
        double inputSum = 0;

        for (Transaction.Input input : tx.getInputs()) {
        // Rule1 交易tx中的所有output必须在UTXOPool中
        UTXO utxo = new UTXO(input.prevTxHash, input.outputIndex);
        if (!utxoPool.contains(utxo)) return false;

        // Rule2 input中的Signature必须是有效的，使用已经提供的验证方法来实现
        Transaction.Output output = utxoPool.getTxOutput(utxo);
        if (output == null) return false;
        inputSum += output.value;
        if (!Crypto.verifySignature(output.address, tx.getRawDataToSign(tx.getInputs().indexOf(input)), input.signature)) {
            return false;
        }

        // Rule3 不能双花
        UTXOPool claimedUtxo = new UTXOPool();
        if (claimedUtxo.contains(utxo)) return false;
        claimedUtxo.addUTXO(utxo, output);
    }
    for (Transaction.Output output : tx.getOutputs()) {
        // Rule4 非负
        if (output.value < 0) return false;
        outputSum += output.value;
    }

    // Rule5  input<output
    if (inputSum < outputSum) return false;
    return true;
}
```



##### 3、public Transaction[] handleTxs(Transaction[] possibleTxs); 

给了一组乱序的交易TX[]，返回其中有效的交易。

每次遍历，看看是否结果有更新，如果有继续遍历，直到没有为止，最终一定会收敛到全部加入。

```java
public Transaction[] handleTxs(Transaction[] possibleTxs) {
        // IMPLEMENT THIS
        Set<Transaction> transactions = new HashSet<Transaction>();
        for (Transaction tx : possibleTxs) {
            if (isValidTx(tx)) {
                transactions.add(tx);
                for (Transaction.Input input : tx.getInputs()) {
                    UTXO utxo = new UTXO(input.prevTxHash, input.outputIndex);
                    utxoPool.removeUTXO(utxo);
                }
                for (int i = 0; i < tx.numOutputs(); i++) {
                    Transaction.Output output = tx.getOutput(i);
                    utxoPool.addUTXO(new UTXO(tx.getHash(), i), output);
                }
            }

        }
        Transaction[] validAr = new Transaction[transactions.size()];
        return transactions.toArray(validAr);

    }
```